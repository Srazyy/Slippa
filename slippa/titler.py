"""
Titler module â€” auto-generates titles and descriptions for clips.

Uses the transcript text to extract catchy, YouTube-ready titles
and descriptions. Works entirely from the text already available
in the pipeline â€” no extra API calls or model downloads.

Strategy:
    Title:
        1. Look for a strong hook sentence (question, exclamation, hook phrase).
        2. Fall back to the noun-phrase-richest sentence.
        3. Clean up and cap at ~60 characters.

    Description:
        1. First 2-3 sentences as a summary.
        2. Auto-generated hashtags from key noun phrases.
"""

import re
from textblob import TextBlob


# Max lengths
MAX_TITLE_LENGTH = 60
MAX_DESCRIPTION_LENGTH = 500
MAX_HASHTAGS = 5

# Hook patterns (reused from scorer â€” phrases that make good titles)
_HOOK_RE = re.compile(
    r"(here'?s the thing|the truth is|let me tell you|you need to|"
    r"you have to|number one|first of all|most important|"
    r"don'?t make this mistake|stop doing|the secret|the biggest)",
    re.IGNORECASE,
)

# Words to skip in hashtags (common filler)
_STOP_WORDS = {
    "the", "a", "an", "is", "are", "was", "were", "be", "been",
    "this", "that", "these", "those", "it", "its", "i", "you",
    "we", "they", "he", "she", "my", "your", "our", "their",
    "of", "in", "to", "for", "with", "on", "at", "from", "by",
    "about", "like", "just", "really", "very", "so", "but", "and",
    "or", "not", "no", "do", "does", "did", "have", "has", "had",
    "will", "would", "could", "should", "can", "may", "might",
    "thing", "things", "something", "anything", "everything",
    "people", "way", "lot", "kind", "going", "think", "know",
    "want", "get", "got", "make", "made", "say", "said", "one",
}


def generate_title(text: str) -> str:
    """
    Generate a catchy title from clip transcript text.

    Args:
        text: The transcript text of the clip.

    Returns:
        A title string, max ~60 characters.
    """
    if not text or not text.strip():
        return "Untitled Clip"

    blob = TextBlob(text.strip())
    sentences = [str(s).strip() for s in blob.sentences if len(str(s).strip()) > 5]

    if not sentences:
        return _truncate(text.strip(), MAX_TITLE_LENGTH)

    # Strategy 1: Find a sentence with a hook phrase
    for sent in sentences:
        if _HOOK_RE.search(sent):
            return _clean_title(sent)

    # Strategy 2: Find a question (questions make great titles)
    for sent in sentences:
        if "?" in sent:
            return _clean_title(sent)

    # Strategy 3: Find a sentence with an exclamation
    for sent in sentences:
        if "!" in sent:
            return _clean_title(sent)

    # Strategy 4: Pick the most noun-phrase-rich sentence
    best_sent = sentences[0]
    best_np_count = 0
    for sent in sentences[:8]:  # check first 8 sentences
        sent_blob = TextBlob(sent)
        np_count = len(sent_blob.noun_phrases)
        if np_count > best_np_count:
            best_np_count = np_count
            best_sent = sent

    return _clean_title(best_sent)


def generate_description(text: str, video_title: str = "") -> str:
    """
    Generate a YouTube-ready description from clip transcript text.

    Args:
        text: The transcript text of the clip.
        video_title: Original video title (optional, used for context).

    Returns:
        Description string with summary + hashtags.
    """
    if not text or not text.strip():
        return "Generated by Slippa"

    blob = TextBlob(text.strip())
    sentences = [str(s).strip() for s in blob.sentences if len(str(s).strip()) > 10]

    # Summary: first 2-3 sentences, capped at 280 chars
    summary_parts = []
    summary_len = 0
    for sent in sentences[:3]:
        if summary_len + len(sent) > 280:
            break
        summary_parts.append(sent)
        summary_len += len(sent)

    summary = " ".join(summary_parts) if summary_parts else text[:200].strip()

    # Hashtags from noun phrases
    hashtags = _generate_hashtags(blob)

    # Build description
    parts = []

    if summary:
        parts.append(summary)

    if video_title:
        parts.append(f"\nðŸ“º From: {video_title}")

    if hashtags:
        parts.append("\n" + " ".join(hashtags))

    parts.append("\nðŸŽ¬ Generated by Slippa")

    description = "\n".join(parts)

    # Cap total length
    if len(description) > MAX_DESCRIPTION_LENGTH:
        description = description[:MAX_DESCRIPTION_LENGTH - 3] + "..."

    return description


def _generate_hashtags(blob: TextBlob) -> list[str]:
    """Extract hashtags from noun phrases."""
    noun_phrases = blob.noun_phrases

    # Score noun phrases by frequency and length
    np_scores = {}
    for np in noun_phrases:
        # Skip very short or very long phrases
        words = np.split()
        if len(words) > 3 or len(np) < 3:
            continue
        # Skip if all words are stop words
        if all(w.lower() in _STOP_WORDS for w in words):
            continue
        np_scores[np] = np_scores.get(np, 0) + 1

    # Sort by frequency, take top N
    sorted_nps = sorted(np_scores.items(), key=lambda x: x[1], reverse=True)
    hashtags = []

    for np, _ in sorted_nps[:MAX_HASHTAGS]:
        # Convert to hashtag: "machine learning" â†’ "#MachineLearning"
        # Strip non-alpha chars from each word
        clean_words = [re.sub(r"[^a-zA-Z0-9]", "", w) for w in np.split()]
        clean_words = [w for w in clean_words if w]  # drop empties
        if clean_words:
            tag = "#" + "".join(w.capitalize() for w in clean_words)
            hashtags.append(tag)

    return hashtags


def _clean_title(sentence: str) -> str:
    """Clean up a sentence to use as a title."""
    title = sentence.strip()

    # Remove trailing periods (but keep ? and !)
    title = title.rstrip(".")

    # Remove leading filler words
    title = re.sub(
        r"^(so|well|okay|ok|um|uh|like|basically|and|but|now)\s+",
        "", title, flags=re.IGNORECASE,
    )

    # Capitalize first letter
    if title:
        title = title[0].upper() + title[1:]

    return _truncate(title, MAX_TITLE_LENGTH)


def _truncate(text: str, max_len: int) -> str:
    """Truncate text to max_len, breaking at word boundary."""
    if len(text) <= max_len:
        return text

    # Find last space before max_len
    truncated = text[:max_len]
    last_space = truncated.rfind(" ")
    if last_space > max_len * 0.5:
        truncated = truncated[:last_space]

    return truncated.rstrip(" ,;:-") + "â€¦"
