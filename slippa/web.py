"""
Flask web application for Slippa.

Routes:
    /              ‚Üí Dashboard (paste YouTube URL or upload file)
    /batch         ‚Üí Batch processing (multiple URLs)
    /history       ‚Üí Job history
    /settings      ‚Üí Settings page
    /process       ‚Üí POST: starts processing a video
    /batch-process ‚Üí POST: starts batch processing
    /status/<id>   ‚Üí GET: returns processing status (JSON)
    /results/<id>  ‚Üí Results page with clip previews
    /download/<id>/<clip> ‚Üí Download a specific clip
    /clips/<path>  ‚Üí Serve clip video files
    /youtube/auth  ‚Üí Start YouTube OAuth2 login
    /oauth/callback ‚Üí Handle OAuth2 callback
    /upload        ‚Üí POST: upload a clip to YouTube
    /upload-status ‚Üí GET: check upload status
"""

import os
import uuid
import threading
from datetime import datetime
from flask import (
    Flask, render_template, request, jsonify,
    send_from_directory, redirect, url_for
)

from slippa.downloader import download_video
from slippa.transcriber import transcribe_audio
from slippa.clipper import find_clips
from slippa.cutter import cut_clips
from slippa.titler import generate_title, generate_description
from slippa import uploader
from slippa import database as db
from config import settings as config

app = Flask(
    __name__,
    template_folder=os.path.join(os.path.dirname(__file__), "..", "templates"),
    static_folder=os.path.join(os.path.dirname(__file__), "..", "static"),
)

# Initialise database on import
db.init_db()

# In-memory cache for active processing threads + upload jobs
_active_jobs = {}
upload_jobs = {}


def _process_video(job_id: str, source: str):
    """Background thread: runs the full pipeline for one video."""
    settings = config.load_settings()

    try:
        # Step 1: Download
        db.update_job(job_id, status="downloading", progress="Downloading video...")

        if source.startswith(("http://", "https://", "www.")):
            video_path = download_video(source, output_dir=settings["download_dir"])
        else:
            video_path = source

        title = os.path.splitext(os.path.basename(video_path))[0]
        db.update_job(job_id, video_title=title, progress=f"Downloaded: {title}")

        # Step 2: Transcribe
        db.update_job(job_id, status="transcribing",
                      progress=f"Transcribing with Whisper ({settings['whisper_model']})...")

        segments = transcribe_audio(video_path, model_size=settings["whisper_model"])
        db.update_job(job_id, progress=f"Transcribed {len(segments)} segments")

        # Step 3: Find clips
        smart_scoring = settings.get("smart_scoring", True)
        scoring_mode = "smart AI" if smart_scoring else "legacy"
        db.update_job(job_id, status="analyzing",
                      progress=f"Analyzing transcript ({scoring_mode} scoring)...")

        clips = find_clips(
            segments,
            min_duration=settings["min_clip_duration"],
            max_duration=settings["max_clip_duration"],
            max_clips=settings["max_clips"],
            smart_edit=settings.get("smart_edit", False),
            gap_threshold=settings.get("gap_threshold", 0.8),
            smart_scoring=smart_scoring,
        )
        db.update_job(job_id, progress=f"Found {len(clips)} clips")

        if not clips:
            db.update_job(job_id, status="done",
                          progress="No clips found in this video.", clips=[])
            return

        # Step 4: Cut clips
        db.update_job(job_id, status="cutting",
                      progress="Cutting clips with ffmpeg...")

        clip_output_dir = os.path.join(settings["clips_dir"], job_id)
        clip_paths = cut_clips(
            video_path, clips,
            output_dir=clip_output_dir,
            smart_edit=settings.get("smart_edit", False),
            output_format=settings.get("output_format", "horizontal"),
        )

        auto_titles = settings.get("auto_titles", True)

        clip_info = []
        for i, (path, clip_data) in enumerate(zip(clip_paths, clips)):
            duration = clip_data["end"] - clip_data["start"]
            clip_text = clip_data.get("text", "")

            # Auto-generate title and description
            if auto_titles and clip_text:
                auto_title = generate_title(clip_text)
                auto_desc = generate_description(clip_text, title)
            else:
                auto_title = f"Clip {i + 1}"
                auto_desc = f"Clip from {title} ‚Äî Generated by Slippa"

            clip_info.append({
                "index": i + 1,
                "filename": os.path.basename(path),
                "start": round(clip_data["start"], 1),
                "end": round(clip_data["end"], 1),
                "duration": round(duration, 1),
                "score": clip_data["score"],
                "label": clip_data.get("label", "‚Äî"),
                "score_breakdown": clip_data.get("score_breakdown", {}),
                "text": clip_text[:200],
                "auto_title": auto_title,
                "auto_description": auto_desc,
                "size_kb": round(os.path.getsize(path) / 1024, 1),
            })

        db.update_job(job_id, status="done",
                      progress=f"Done! {len(clip_info)} clips ready.", clips=clip_info)

    except Exception as e:
        db.update_job(job_id, status="error", progress=f"Error: {str(e)}", error=str(e))


# ---- Page Routes ----

@app.route("/")
def index():
    return render_template("index.html", page="home")


@app.route("/batch")
def batch_page():
    return render_template("batch.html", page="batch")


@app.route("/history")
def history_page():
    sorted_jobs = db.list_jobs()
    return render_template("history.html", page="history", jobs=sorted_jobs)


@app.route("/settings")
def settings_page():
    current = config.load_settings()
    return render_template(
        "settings.html",
        page="settings",
        settings=current,
        whisper_models=config.WHISPER_MODELS,
    )


@app.route("/settings", methods=["POST"])
def save_settings_route():
    new_settings = {
        "whisper_model": request.form.get("whisper_model", "base"),
        "min_clip_duration": int(request.form.get("min_clip_duration", 15)),
        "max_clip_duration": int(request.form.get("max_clip_duration", 90)),
        "target_clip_duration": int(request.form.get("target_clip_duration", 45)),
        "max_clips": int(request.form.get("max_clips", 10)),
        "smart_edit": request.form.get("smart_edit") == "on",
        "gap_threshold": float(request.form.get("gap_threshold", 0.8)),
        "output_format": request.form.get("output_format", "horizontal"),
        "default_privacy": request.form.get("default_privacy", "private"),
        "smart_scoring": request.form.get("smart_scoring") == "on",
        "auto_titles": request.form.get("auto_titles") == "on",
    }
    current = config.load_settings()
    current.update(new_settings)
    config.save_settings(current)
    return redirect(url_for("settings_page"))


# ---- Processing Routes ----

@app.route("/process", methods=["POST"])
def process():
    source = request.form.get("source", "").strip()
    if not source:
        return jsonify({"error": "No source provided"}), 400

    job_id = str(uuid.uuid4())[:8]
    db.create_job(job_id, source)

    thread = threading.Thread(target=_process_video, args=(job_id, source))
    thread.daemon = True
    thread.start()

    return jsonify({"job_id": job_id})


@app.route("/batch-process", methods=["POST"])
def batch_process():
    """Process multiple URLs at once."""
    urls_text = request.form.get("urls", "").strip()
    if not urls_text:
        return jsonify({"error": "No URLs provided"}), 400

    urls = [u.strip() for u in urls_text.splitlines() if u.strip()]
    if not urls:
        return jsonify({"error": "No valid URLs found"}), 400

    job_ids = []
    for url in urls:
        job_id = str(uuid.uuid4())[:8]
        db.create_job(job_id, url, batch=True)
        job_ids.append(job_id)

    # Process sequentially in a background thread
    def _batch_runner(ids):
        for jid in ids:
            job = db.get_job(jid)
            _process_video(jid, job["source"])

    thread = threading.Thread(target=_batch_runner, args=(job_ids,))
    thread.daemon = True
    thread.start()

    return jsonify({"job_ids": job_ids})


@app.route("/status/<job_id>")
def status(job_id):
    job = db.get_job(job_id)
    if not job:
        return jsonify({"error": "Job not found"}), 404
    return jsonify(job)


@app.route("/results/<job_id>")
def results(job_id):
    job = db.get_job(job_id)
    if not job:
        return redirect(url_for("index"))
    return render_template("results.html", job_id=job_id, job=job, page="home")


@app.route("/clips/<job_id>/<filename>")
def serve_clip(job_id, filename):
    settings = config.load_settings()
    clip_dir = os.path.join(os.getcwd(), settings["clips_dir"], job_id)
    return send_from_directory(clip_dir, filename)


@app.route("/download/<job_id>/<filename>")
def download_clip(job_id, filename):
    settings = config.load_settings()
    clip_dir = os.path.join(os.getcwd(), settings["clips_dir"], job_id)
    return send_from_directory(clip_dir, filename, as_attachment=True)


# ---- YouTube Upload Routes ----

@app.route("/youtube/status")
def youtube_status():
    return jsonify({
        "configured": uploader.is_configured(),
        "authenticated": uploader.is_authenticated(),
    })


@app.route("/youtube/auth")
def youtube_auth():
    try:
        auth_url = uploader.get_auth_url()
        return redirect(auth_url)
    except FileNotFoundError as e:
        return jsonify({"error": str(e)}), 400


@app.route("/oauth/callback")
def oauth_callback():
    try:
        uploader.handle_oauth_callback(request.url)
        return render_template("auth_success.html")
    except Exception as e:
        return jsonify({"error": f"Authentication failed: {str(e)}"}), 400


@app.route("/upload", methods=["POST"])
def upload_clip_to_youtube():
    data = request.get_json()
    job_id = data.get("job_id")
    filename = data.get("filename")
    title = data.get("title", filename)
    description = data.get("description", "Generated by Slippa")
    privacy = data.get("privacy", config.get("default_privacy"))

    if not job_id or not filename:
        return jsonify({"error": "Missing job_id or filename"}), 400

    if not uploader.is_authenticated():
        return jsonify({"error": "Not authenticated.", "need_auth": True}), 401

    clip_path = os.path.join(os.getcwd(), config.load_settings()["clips_dir"], job_id, filename)
    if not os.path.exists(clip_path):
        return jsonify({"error": "Clip file not found"}), 404

    upload_id = f"{job_id}_{filename}"
    upload_jobs[upload_id] = {"status": "uploading", "progress": "Starting...", "result": None}

    def _do_upload():
        try:
            result = uploader.upload_video(
                file_path=clip_path, title=title,
                description=description, privacy_status=privacy,
            )
            upload_jobs[upload_id] = {"status": "done", "progress": "Uploaded!", "result": result}
        except Exception as e:
            upload_jobs[upload_id] = {"status": "error", "progress": str(e), "result": None}

    thread = threading.Thread(target=_do_upload)
    thread.daemon = True
    thread.start()
    return jsonify({"upload_id": upload_id})


@app.route("/upload-status/<upload_id>")
def upload_status(upload_id):
    job = upload_jobs.get(upload_id)
    if not job:
        return jsonify({"error": "Upload not found"}), 404
    return jsonify(job)


# ---- Server ----

def run_web():
    yt_status = "‚úÖ configured" if uploader.is_configured() else "‚ùå no client_secrets.json"
    print(f"\nüåê Slippa Web UI running at: http://localhost:5000")
    print(f"üì§ YouTube upload: {yt_status}\n")
    app.run(debug=True, port=5000, use_reloader=False)


if __name__ == "__main__":
    run_web()
